# **Feature 1: Live View of Flights**

Summary

![Active Flight Updater](./images/active-flight-updater.png)

## Active Flight Data Update 

To update `Tile38` with the current position of all active flights, you can leverage its real-time geospatial capabilities to store and track the locations of flights. Tile38 works by storing geographic objects, such as points, in a spatial index, and allows for efficient real-time updates and queries on those objects. For each flight, you would store the flight's unique ID along with its current latitude and longitude as a geospatial point. To update the flight's position, the **SET** command is used, which updates or adds a new geospatial object for the flight. This can be done as frequently as needed (e.g., every few seconds) to keep the flight locations current.

For example, to update a flight with ID "flight123" to a new position with latitude `40.730610` and longitude `-73.935242`, you would issue the following command:
```bash
SET fleet flight123 POINT 40.730610 -73.935242
```
This command adds or updates the location of "flight123" in the `fleet` collection, using a `POINT` object to represent the geospatial coordinates. This operation would be repeated for each active flight in your system, ensuring that Tile38 is continually updated with the latest positions.

To retrieve a set of flights within a geographic bounding box, you can use Tile38’s **WITHIN** command. The bounding box is defined by two sets of coordinates: the southwest corner (min latitude/longitude) and the northeast corner (max latitude/longitude). This command will return all flights whose positions fall within the specified bounding box. For example, if you want to query for all flights within a bounding box that extends from latitude `40.0` to `41.0` and longitude `-74.0` to `-73.0`, you would run the following command:
```bash
WITHIN fleet BOUNDS 40.0 -74.0 41.0 -73.0
```
This command queries the `fleet` collection and returns all flight objects whose geospatial points fall within the given bounding box. Tile38 efficiently handles these queries, making it suitable for real-time applications like flight tracking, where you need to frequently query and update spatial data.



3. **Storage Layer**:
   - The live flight data is stored in an in-memory database (e.g., Redis or Memcached) to minimize access latency.
   - The system stores the current state of each flight keyed by flight ID.

#### 3.2 **Data Model**


- **Flight Table** (In-memory cache):
  ```
  flight_id (PK) | latitude | longitude | altitude | airspeed | last_updated
  ```

- **Geolocation Index** (In-memory grid):
  ```
  grid_id (PK) | flight_ids (List of flight IDs within this grid)
  ```



#### 3.3 **Storage Solution**

- **Tile38**: Chosen due to their ability to handle high-throughput and low-latency access. It provides fast in-memory storage and can handle bounding box queries natively. 


They provide efficient key-value storage for real-time data. Redis supports geospatial indexing and can serve as a cache for flight locations.




#### 3.4 **Query and API Design**



- **API Endpoint**: `GET /api/flights?bounds=<lat1,long1,lat2,long2>`
  - **Request**: The client provides the bounds of the map.
  - **Response**: A list of flights within the bounds, including flight ID, location, altitude, and airspeed.
  
- **Query Execution**:
  - Geolocation grids allow for efficient querying. When a request is made, the API queries Redis for flights in the specific geolocation grid, retrieves their data, and serves the response.




Yes, you can interact with **Tile38** using Python to update flight positions and retrieve flights within a geo-bounding box. There’s a Python library called **tile38-py** that allows you to communicate with a Tile38 server via its Redis-like API. Below is an example of how you can use Python to update the positions of flights in Tile38 and retrieve flights within a bounding box.

### **1. Install Tile38 Python Client**
First, you need to install the **tile38-py** library to interact with the Tile38 server.

```bash
pip install tile38-py
```

### **2. Python Code to Update Flight Positions and Query Within a Bounding Box**

Here’s an example of how you would use Python to update the flight positions and retrieve flights within a bounding box:

```python
from tile38 import Tile38

# Connect to Tile38 server (assuming it's running on localhost at default port 9851)
client = Tile38(url='redis://localhost:9851')

# Function to update flight position in Tile38
def update_flight_position(flight_id, latitude, longitude):
    # Using the 'fleet' collection to store flight positions
    client.set('fleet', flight_id).point(latitude, longitude)
    print(f"Updated flight {flight_id} to position lat: {latitude}, lon: {longitude}")

# Function to retrieve flights within a bounding box
def get_flights_in_bounding_box(min_lat, min_lon, max_lat, max_lon):
    # Query the 'fleet' collection for flights within the bounding box
    response = client.within('fleet').bounds(min_lat, min_lon, max_lat, max_lon).asObjects()
    flights = response['objects']
    
    print(f"Flights within bounding box ({min_lat}, {min_lon}), ({max_lat}, {max_lon}):")
    for flight in flights:
        print(f"Flight ID: {flight['id']}, Location: {flight['object']['coordinates']}")
    return flights

# Example: Update a flight position
update_flight_position("flight123", 40.730610, -73.935242)
update_flight_position("flight456", 34.052235, -118.243683)

# Example: Query flights within a bounding box
get_flights_in_bounding_box(40.0, -74.0, 41.0, -73.0)
```

### **Explanation:**

1. **Tile38 Client Initialization**:
   - The `Tile38` object is initialized using the `url` parameter that points to your Tile38 server. Here, it's assumed that the server is running locally on the default port `9851`.

2. **Update Flight Position**:
   - The `update_flight_position` function uses the `SET` command to update the flight's position in the `fleet` collection.
   - For each flight, you provide the `flight_id`, latitude, and longitude, and the position is stored as a point in Tile38.

3. **Retrieve Flights Within Bounding Box**:
   - The `get_flights_in_bounding_box` function uses the `WITHIN` command to query for flights within the specified geographic bounding box.
   - The bounding box is defined by two sets of coordinates: the southwest corner (`min_lat`, `min_lon`) and the northeast corner (`max_lat`, `max_lon`).
   - The `asObjects()` function retrieves the results as a JSON-like object, which includes the flight IDs and their coordinates.

### **Output Example**:

```bash
Updated flight flight123 to position lat: 40.73061, lon: -73.935242
Updated flight flight456 to position lat: 34.052235, lon: -118.243683
Flights within bounding box (40.0, -74.0), (41.0, -73.0):
Flight ID: flight123, Location: [-73.935242, 40.73061]
```

### **Use Case**:
This approach allows you to track and manage flight data efficiently. By continuously updating flight positions, you can maintain real-time data about active flights in Tile38. When querying flights within a geographic region, Tile38’s geospatial indexing ensures fast responses, even with large volumes of data.

You can extend this approach for additional features, such as real-time notifications using Tile38’s **Geofencing** capabilities, where you can be alerted when flights enter or leave specific geographic areas.







### GEOTILING 


To set up a geotiling system that efficiently displays all active flights in a specified area at any zoom level, we need to design a system that can quickly ingest and process real-time aircraft position updates and serve the data based on geographic location. The system must handle large-scale data for global flights while providing low-latency queries for clients at various zoom levels. Here's how I would approach it:

### **1. Data Ingestion and Geospatial Encoding**
We are receiving continuous position updates for aircraft globally, likely every few seconds. To efficiently handle this data, the system should:

- **Ingest Aircraft Data**: Each aircraft provides a stream of updates including aircraft ID, latitude, longitude, altitude, and metadata (flight number, airline, etc.).
- **Geohashing**: For each update, use a **geohash** or **quadkey** to convert the aircraft's latitude and longitude into a geospatial tile coordinate. A geohash encodes geographic locations into a compact string, where the precision of the string depends on the number of characters (similar to zoom levels in a map).
  - For example, a shorter geohash represents a larger area (low zoom level), while a longer geohash represents a smaller area (high zoom level).

### **2. Tiling System Design**
The tiling system must support zoom levels and geographic queries at any scale. Here’s how we can design the geotiling structure:

- **Quadtrees**: The Earth is divided into a hierarchical structure of tiles, where each tile is subdivided into four smaller tiles as zoom levels increase. This gives us an efficient way to organize and retrieve flight data at different resolutions.
  - **Tile Identifier (Tile ID)**: Each tile at a specific zoom level is identified by an (X, Y, Z) coordinate, where X and Y represent the position of the tile, and Z represents the zoom level.
  - **Zoom Level**: Zoom level 0 might cover the entire globe in one tile, and increasing the zoom level (e.g., Z=1, Z=2) will subdivide the tiles into increasingly smaller sections.

- **Data Storage for Tiles**:
  - For each tile at each zoom level, we store the flight data for the flights currently within that tile. This could be implemented using a spatial index such as **R-tree** or **QuadTree**, which supports efficient spatial querying.
  - Alternatively, we can store data in a **key-value store** like Redis, where the key is the tile identifier (geohash or quadkey) and the value is a list of active flights within that tile.

### **3. Updating the Tile Data with Flight Position Updates**
Whenever an aircraft provides a position update, the system must:
- **Calculate the Geohash**: Convert the latitude and longitude of the aircraft into a geohash or tile identifier (depending on the precision needed for the zoom level).
- **Update the Correct Tile**: The flight is added to the list of active flights in the corresponding tile. If the aircraft moves out of a tile, remove it from the previous tile and add it to the new one.
  - **In-memory Cache (Redis)**: Use an in-memory key-value store (e.g., Redis) to store the current list of flights for each tile. This provides fast read and write access for real-time updates.

### **4. Efficient Querying for Map Display**
When a user queries the map at a specific zoom level, the system needs to retrieve the relevant flights within the visible tiles. Here’s how we handle the queries:

- **Identify Visible Tiles**: Based on the map bounds (latitude/longitude range) and the zoom level, determine which tiles are visible in the user's view.
  - For example, at zoom level Z=4, you might be displaying a grid of tiles over a small region (e.g., a city).
  - Calculate the tile coordinates (X, Y, Z) for the bounding box of the view area.

- **Query the Relevant Tiles**: Fetch the flight data for each tile within the view. Since the flight data for each tile is stored in Redis or a similar store, retrieving the flight list for each tile is fast.
  - **Redis Example**:
    ```bash
    GET flights_in_tile:{geohash}  # Returns the list of flights in the tile
    ```
  - Aggregate the data across all visible tiles and return it to the client.

- **Zoom Level Optimization**: Depending on the zoom level, the system can dynamically adjust the precision of geohashes or quadkeys.
  - At low zoom levels (zoomed out), use fewer characters of the geohash, resulting in larger tiles with many flights.
  - At high zoom levels (zoomed in), use more characters to generate smaller tiles, resulting in fewer flights per tile.

### **5. Handling Zoom Level Transitions**
As the user zooms in and out of the map:
- **Merge Data at Low Zoom Levels**: When zoomed out, the system should group flights that are in nearby tiles together. This can be done by aggregating data from multiple tiles or by using a coarser geohash.
  - Example: At zoom level Z=1, flights in neighboring tiles (e.g., geohash `abcd`, `abce`, `abcf`) might be displayed together to avoid cluttering the map.

- **Detail at High Zoom Levels**: At higher zoom levels, the system retrieves more precise tile data (smaller tiles) and displays more detailed information, such as individual flight paths or metadata about each flight.

### **6. Data Partitioning and Sharding for Scalability**
Given the large scale of flight data, the system needs to scale horizontally:
- **Sharding by Tile Key**: Partition the data by geohash or tile key, with each shard handling a specific geographic region. This allows the system to distribute the load across multiple servers.
  - Redis or another distributed cache can be used to shard the data across multiple nodes.
  
- **Load Balancing**: The queries can be load-balanced across multiple servers based on geographic region or user location, ensuring high availability and minimizing latency.

### **7. Summary of the System Design**
1. **Data Ingestion**: Aircraft position updates are ingested and geohashed.
2. **Tiling System**: A quadtree structure is used to divide the world into tiles at different zoom levels, each tile storing the current flights within it.
3. **Storage**: Store active flights in tiles using Redis or another in-memory cache, keyed by geohash or quadkey.
4. **Querying**: When a user views the map, visible tiles are identified and queried for flight data.
5. **Scalability**: Use sharding and distributed storage to handle the global scale of flight data, ensuring fast responses and low latency.

### **Technologies**:
- **Redis**: For fast storage and retrieval of tile data.
- **Geohashing/Quadtrees**: For efficient spatial indexing.
- **Apache Kafka**: For ingesting real-time flight position updates.
- **Load Balancers**: To distribute queries across servers.

By combining real-time geospatial indexing with efficient data storage and querying, this system can handle large-scale flight tracking and provide users with quick, accurate map updates at any zoom level.






To store a latitude, longitude, and a string identifier (such as a flight ID) in a Tile38 database, you can use the `SET` command. The general syntax for storing geospatial data (e.g., points) with an associated key is as follows:

```bash
SET key id FIELD field_name field_value POINT lat lon
```

Here’s how you can store a flight's latitude and longitude with a flight ID:

### Example:
Let's say you have a flight with the following data:
- Flight ID: `flight123`
- Latitude: `37.7749`
- Longitude: `-122.4194`

You can store this information using the following Tile38 command:

```bash
SET flights flight123 POINT 37.7749 -122.4194
```

This command does the following:
- `flights`: The key (or collection) under which the flight data is stored.
- `flight123`: The unique ID (the flight identifier in this case).
- `POINT`: The geospatial data type that stores latitude and longitude.
- `37.7749`: Latitude of the flight.
- `-122.4194`: Longitude of the flight.

### Storing additional fields (optional):
If you want to store additional information about the flight (e.g., altitude, speed, etc.), you can add custom fields using the `FIELD` keyword:

```bash
SET flights flight123 FIELD altitude 30000 FIELD speed 500 POINT 37.7749 -122.4194
```

In this case, you're also storing the flight's altitude (30,000 feet) and speed (500 knots).

Now, your flight with ID `flight123` is stored in the `flights` key with the latitude and longitude, along with optional fields like altitude and speed.








To send the current flight position from a Protobuf message to a Tile38 database using the Python Tile38 library, you first need to deserialize the Protobuf message, extract the relevant data (latitude, longitude, flight ID, altitude, and airspeed), and store this information into Tile38.

### Steps:
1. **Install dependencies:**
   You need the following Python packages:
   - `protobuf` for handling Protobuf messages.
   - `tile38` for interacting with the Tile38 database.

   Install them via pip:
   ```bash
   pip install protobuf tile38
   ```

2. **Define the Protobuf schema:**
   You will generate Python classes from your `.proto` file using the `protoc` compiler. For the sake of simplicity, I will assume you've already compiled your `.proto` file into Python classes.

   If you haven’t done this yet, here’s how:
   ```bash
   protoc --python_out=. your_file.proto
   ```

3. **Write the Python code:**
   Below is an example of how to deserialize the Protobuf message and insert the flight data into a Tile38 database using the Python Tile38 library:


```python
import tile38
from flight_data_pb2 import FlightData

# Initialize Tile38 client
client = tile38.Tile38()

def update_flight(flight_data: FlightData):
    # Store the flight data in Tile38 with altitude, airspeed, and metadata as fields
    # The collection is named `flights`, and each flight is stored with its `flight_id`. Fields like # # # # altitude and airspeed are stored alongside the geospatial data (latitude and longitude).
    client.set('active_flights', flight_data.flight_id).fields(
        altitude=flight_data.altitude,
        airspeed=flight_data.airspeed,
        airline=flight_data.metadata.airline,
        flight_number=flight_data.metadata.flight_number,
        departure_airport=flight_data.metadata.departure_airport,
        arrival_airport=flight_data.metadata.arrival_airport
    ).point(
      flight_data.location.latitude, 
      flight_data.location.longitude
    )
```

To perform a bounding box query of all active flights within a region using the Tile38 Python client, we will need to use the `bounds` query. Tile38 is optimized for high-performance geospatial queries and should scale well with millions of queries per second when deployed appropriately.

Here’s a Python implementation that performs a bounding box query and is optimized for scalability. I'll also explain how to ensure it scales for high throughput scenarios.

### Steps to implement:
1. **Initialize the Tile38 client.**
2. **Define the bounding box query.**
3. **Optimize for performance by batching or sharding queries (depending on the size of your Tile38 cluster).**

### Code Example:

```python
import tile38

# Initialize Tile38 client
client = tile38.Tile38()

def get_active_flights_in_region(min_lat, min_lon, max_lat, max_lon):
    """
    Queries all flights within a bounding box defined by (min_lat, min_lon) and (max_lat, max_lon).
    
    :param min_lat: Minimum latitude (Southwest corner of the bounding box).
    :param min_lon: Minimum longitude (Southwest corner of the bounding box).
    :param max_lat: Maximum latitude (Northeast corner of the bounding box).
    :param max_lon: Maximum longitude (Northeast corner of the bounding box).
    :return: List of flights within the bounding box.
    """
    
    # Perform the bounding box query
    response = client.within('flights').bounds(min_lat, min_lon, max_lat, max_lon).asObjects()

    # Extract and return flight data from the response
    active_flights = response.get('objects', [])

    print(f"Found {len(active_flights)} active flights in the region.")
    
    # Optionally, you can further process or return the list of active flights
    return active_flights

# Example: Bounding box for a specific region
min_lat = 30.0  # Example: Southwest latitude
min_lon = -120.0  # Example: Southwest longitude
max_lat = 40.0  # Example: Northeast latitude
max_lon = -110.0  # Example: Northeast longitude

# Fetch flights within the bounding box
active_flights = get_active_flights_in_region(min_lat, min_lon, max_lat, max_lon)

# Output example
for flight in active_flights:
    flight_id = flight['id']
    lat = flight['object']['coordinates'][1]
    lon = flight['object']['coordinates'][0]
    print(f"Flight {flight_id} is at location ({lat}, {lon})")
```

### Explanation:
1. **Bounding Box Query**: 
   - `client.within('flights').bounds(min_lat, min_lon, max_lat, max_lon).asObjects()`: Queries all flights within the bounding box defined by the minimum and maximum latitude/longitude.
   - The `asObjects()` method retrieves the result as a list of GeoJSON-like objects, each containing flight data such as coordinates and other stored fields (e.g., altitude, speed).
   
2. **Performance**:
   - **Indexing**: Ensure that the Tile38 server has enough memory and appropriate indexing (which it usually does automatically with geospatial data).
   - **Sharding**: If you are working with millions of queries per second, you can scale Tile38 horizontally using sharding, where you partition the data across multiple Tile38 instances. Each shard handles a portion of the spatial data, and the Python client can query each shard as needed.
   - **Caching**: You may use a caching mechanism (like Redis) to cache results of frequent queries to reduce repeated database hits.
   - **Batching**: If querying very large areas, consider splitting the area into smaller regions (using tiling) and querying each region concurrently for efficiency.
   - **Connection Pooling**: If you're making frequent queries, use connection pooling libraries to minimize connection overhead.

3. **Scalability Considerations**:
   - **Load Balancing**: Use a load balancer in front of multiple Tile38 instances to distribute read and write queries evenly.
   - **Cluster Mode**: Tile38 supports clustering, allowing for better scalability as the number of clients and queries grows.
   - **Redis Replication**: Since Tile38 is compatible with Redis, you can also leverage Redis replication for read scaling by querying replica nodes.

### Example Output:

The output of this script will be the flight IDs and their respective latitudes and longitudes within the defined bounding box:

```
Found 3 active flights in the region.
Flight flight123 is at location (37.7749, -122.4194)
Flight flight456 is at location (38.5749, -121.4194)
Flight flight789 is at location (39.7749, -120.4194)
```

### Scaling Considerations:
- **Horizontal Scaling**: Use Tile38's clustering and sharding to scale horizontally, distributing the data across multiple machines.
- **Connection Management**: Manage large-scale query connections using connection pooling.
- **Efficient Queries**: Make use of spatial indexes that Tile38 provides automatically to ensure efficient querying of large datasets.

This approach will allow you to efficiently query large regions for active flights while leveraging Tile38’s performance optimizations for millions of queries per second.









To build a gRPC service that opens a WebSocket to stream real-time updates of active flights within a bounding box, we'll need to implement the following components:

1. **gRPC Server**: The gRPC server will handle client requests and perform the bounding box query to fetch flights.
2. **WebSocket**: This will send real-time updates to clients as flight data changes.
3. **Integration with Tile38**: Use Tile38’s Pub/Sub to get real-time updates about geospatial objects entering, leaving, or moving within a defined geofence (bounding box).

### Steps to Implement:
1. **Define the gRPC service using `.proto`**: Define a service with a streaming RPC for continuous updates.
2. **Set up a WebSocket server**: This server will broadcast real-time flight data updates.
3. **Listen for updates from Tile38**: Subscribe to Tile38’s real-time geofence notifications for flights moving in and out of the bounding box.





### Stream updates to WebSocket clients


Step 1: Define the gRPC `.proto` File

First, create a `.proto` file for the gRPC service that defines a streaming RPC. We’ll include a `Flight` message for each flight's details and a streaming response for real-time updates.

```proto
syntax = "proto3";

service LiveFlightService {
    // Server streaming RPC for flight updates
    rpc StreamActiveFlights (BoundingBox) returns (stream FlightData) {}
}

message BoundingBox {
    double min_latitude = 1;
    double min_longitude = 2;
    double max_latitude = 3;
    double max_longitude = 4;
}

message FlightData {
  // As previously defined
}
```

### Step 2: Implement the gRPC Server with WebSocket Streaming

Below is the Python code to implement the gRPC server using `grpcio` and `websockets` libraries. It subscribes to Tile38’s real-time notifications and streams them to clients via WebSockets.

#### Implement the gRPC server and WebSocket

```python
import grpc
from concurrent import futures
import websockets
import asyncio
import tile38
import time
from flight_pb2_grpc import FlightServiceServicer 
from flight_pb2 import FlightData

# Tile38 client
client = tile38.Tile38()

# Async generator to send flight data to the gRPC stream
async def flight_stream(bbox):
    min_lat, min_lon, max_lat, max_lon = bbox

    # Subscribe to Tile38 geofence events
    async for notification in client.within('active_flights')
      .bounds(min_lat, min_lon, max_lat, max_lon)
      .asFence()
      .exec():
        for obj in notification.get('object', []):
            flight_id = obj['id']
            lat = obj['coordinates'][1]
            lon = obj['coordinates'][0]
            altitude = obj.get('fields', {}).get('altitude', 0)
            airspeed = obj.get('fields', {}).get('airspeed', 0)
            timestamp = time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())

            # Create Flight message to send over gRPC
            flight_data = FlightData(
                flight_id=flight_id,
                latitude=lat,
                longitude=lon,
                altitude=altitude,
                airspeed=airspeed,
                timestamp=timestamp,
                metadata=
            )
            yield flight

class FlightService(flight_pb2_grpc.FlightServiceServicer):
    async def StreamActiveFlights(self, request, context):
        bbox = (request.min_lat, request.min_lon, request.max_lat, request.max_lon)
        async for flight in flight_stream(bbox):
            await context.write(flight)

# Create and start gRPC server
async def serve_grpc():
    server = grpc.aio.server(futures.ThreadPoolExecutor(max_workers=10))
    flight_pb2_grpc.add_FlightServiceServicer_to_server(FlightService(), server)
    server.add_insecure_port('[::]:50051')
    await server.start()
    await server.wait_for_termination()

# WebSocket server to stream flight data
async def websocket_handler(websocket, path):
    # Define the bounding box (can be received via a WebSocket message)
    min_lat, min_lon, max_lat, max_lon = 30.0, -120.0, 40.0, -110.0
    bbox = (min_lat, min_lon, max_lat, max_lon)

    async for flight in flight_stream(bbox):
        # Send flight data over the WebSocket
        await websocket.send(f"Flight {flight.flight_id}: ({flight.latitude}, {flight.longitude}) at {flight.altitude} feet and {flight.airspeed} knots.")

# Start the WebSocket server
async def start_websocket_server():
    async with websockets.serve(websocket_handler, "localhost", 6789):
        await asyncio.Future()  # Run forever

# Main event loop to run both gRPC and WebSocket servers concurrently
async def main():
    await asyncio.gather(serve_grpc(), start_websocket_server())

if __name__ == '__main__':
    asyncio.run(main())
```

### Explanation:

1. **gRPC Server**: 
   - We create a `FlightService` with a `StreamActiveFlights` method that listens for bounding box updates and sends flight data back to the client.
   - The `flight_stream` async generator listens for Tile38 geofence notifications for flights within the bounding box and yields each flight update.

2. **WebSocket Server**:
   - A simple WebSocket server streams updates by subscribing to real-time geofence notifications in Tile38.
   - WebSocket clients receive a continuous stream of flight data (flight ID, position, altitude, and airspeed).

3. **Tile38 Integration**:
   - The `asFence()` method listens to geospatial events from Tile38, ensuring real-time updates when flights move into, out of, or change positions within the bounding box.
   - For each notification, we extract the flight data and yield it to the WebSocket and gRPC clients.

### Step 3: Running the Server

1. **Start the server**:
   Run the Python script, and it will start both the gRPC and WebSocket servers.

2. **WebSocket Clients**:
   You can connect to the WebSocket server from a web client or any WebSocket tool (e.g., `wscat`) and receive real-time updates on flights moving within the bounding box.

   Example using `wscat`:
   ```bash
   wscat -c ws://localhost:6789
   ```

3. **gRPC Clients**:
   You can use any gRPC client (e.g., a Python gRPC client or tools like `grpcurl`) to call the `StreamActiveFlights` service and receive the real-time updates.

### Conclusion:

This implementation opens a WebSocket and gRPC interface for real-time streaming of active flights within a specified bounding box. It integrates with Tile38's geofence and notification system for real-time geospatial updates, ensuring that any flight moving in or out of the bounding box is streamed to the clients instantly.

This setup can be scaled further with sharding, load balancing, or multiple Tile38 instances for larger scale deployments.